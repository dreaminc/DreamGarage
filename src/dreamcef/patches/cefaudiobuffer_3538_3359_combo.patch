diff --git a/BUILD.gn b/BUILD.gn
index bc00907..2e5579b 100644
--- a/BUILD.gn
+++ b/BUILD.gn
@@ -285,6 +285,14 @@ if (is_win) {
 static_library("libcef_static") {
   sources = gypi_paths2.includes_common +
             gypi_paths.autogen_cpp_includes + [
+    "libcef/browser/audio_bus.cc",
+    "libcef/browser/audio_bus.h",
+    "libcef/browser/audio_push_sink.cc",
+    "libcef/browser/audio_push_sink.h",
+    "libcef/browser/audio_mirror_destination.cc",
+    "libcef/browser/audio_mirror_destination.h",
+    "libcef/browser/audio_output_stream.cc",
+    "libcef/browser/audio_output_stream.h",
     "libcef/browser/browser_context.cc",
     "libcef/browser/browser_context.h",
     "libcef/browser/browser_context_impl.cc",
diff --git a/create.bat b/create.bat
new file mode 100644
index 0000000..47c4701
--- /dev/null
+++ b/create.bat
@@ -0,0 +1,4 @@
+set CEF_USE_GN=1
+set GN_DEFINES=use_jumbo_build=true
+set GN_ARGUMENTS=--ide=vs2017 --sln=cef --filters=//cef/*
+call cef_create_projects.bat
\ No newline at end of file
diff --git a/include/cef_audio_bus.h b/include/cef_audio_bus.h
new file mode 100644
index 0000000..696e90e
--- /dev/null
+++ b/include/cef_audio_bus.h
@@ -0,0 +1,82 @@
+// Copyright (c) 2012 Marshall A. Greenblatt. All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+//    * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//    * Redistributions in binary form must reproduce the above
+// copyright notice, this list of conditions and the following disclaimer
+// in the documentation and/or other materials provided with the
+// distribution.
+//    * Neither the name of Google Inc. nor the name Chromium Embedded
+// Framework nor the names of its contributors may be used to endorse
+// or promote products derived from this software without specific prior
+// written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+//
+// ---------------------------------------------------------------------------
+//
+// The contents of this file must follow a specific format in order to
+// support the CEF translator tool. See the translator.README.txt file in the
+// tools directory for more information.
+//
+
+#ifndef CEF_INCLUDE_CEF_AUDIO_BUS_H_
+#define CEF_INCLUDE_CEF_AUDIO_BUS_H_
+#pragma once
+
+#include <vector>
+#include "include/cef_base.h"
+#include "include/cef_drag_data.h"
+#include "include/cef_frame.h"
+#include "include/cef_image.h"
+#include "include/cef_navigation_entry.h"
+#include "include/cef_process_message.h"
+#include "include/cef_request_context.h"
+
+class CefBrowserHost;
+class CefClient;
+///
+// Class used to represent a browser window. When used in the browser process
+// the methods of this class may be called on any thread unless otherwise
+// indicated in the comments. When used in the render process the methods of
+// this class may only be called on the main thread.
+///
+/*--cef(source=library)--*/
+class CefAudioBus : public virtual CefBaseRefCounted {
+public:
+	///
+	// Returns number of frames
+	///
+	/*--cef()--*/
+	virtual int num_frames() = 0;
+
+	///
+	// Gets interleaved float buffer
+	///
+	/*--cef()--*/
+	virtual void ToInterleavedFloatBuffer(int num_frames_to_read,
+		float* dest_buffer) = 0;
+
+	///
+	// Gets interleaved unsigned int8 buffer
+	///
+	/*--cef()--*/
+	virtual void ToInterleavedUint8Buffer(int num_frames_to_read,
+		char* dest_buffer) = 0;
+};
+
+#endif  // CEF_INCLUDE_CEF_AUDIO_BUS_H_
\ No newline at end of file
diff --git a/include/cef_audio_handler.h b/include/cef_audio_handler.h
new file mode 100644
index 0000000..004e1b8
--- /dev/null
+++ b/include/cef_audio_handler.h
@@ -0,0 +1,123 @@
+// Copyright (c) 2015 Marshall A. Greenblatt. All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+//    * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//    * Redistributions in binary form must reproduce the above
+// copyright notice, this list of conditions and the following disclaimer
+// in the documentation and/or other materials provided with the
+// distribution.
+//    * Neither the name of Google Inc. nor the name Chromium Embedded
+// Framework nor the names of its contributors may be used to endorse
+// or promote products derived from this software without specific prior
+// written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+//
+// ---------------------------------------------------------------------------
+//
+// The contents of this file must follow a specific format in order to
+// support the CEF translator tool. See the translator.README.txt file in the
+// tools directory for more information.
+//
+
+// NOTE: This has been borrowed from the pre-existing CEF PR
+// https://bitbucket.org/chromiumembedded/cef/pull-requests/18
+
+#ifndef CEF_INCLUDE_CEF_AUDIO_HANDLER_H_
+#define CEF_INCLUDE_CEF_AUDIO_HANDLER_H_
+#pragma once
+
+#include "include/cef_base.h"
+#include "include/cef_browser.h"
+#include "include/cef_audio_bus.h"
+
+///
+// Implement this interface to handle audio events
+///
+/*--cef(source=client)--*/
+class CefAudioHandler : public virtual CefBaseRefCounted {
+public:
+	///
+	// Event handler for every new audio stream, |audio_stream_id|
+	// will identify this stream in future events, and is unique across 
+	// all other audio stream. OnAudioStreamStarted can be called also 
+	// after OnAudioSteamStopped was called.
+	//
+	// Will be called on the UI thread 
+	///
+	/*--cef()--*/
+	virtual void OnAudioStreamStarted(CefRefPtr<CefBrowser> browser,
+		int audio_stream_id,
+		int sample_rate,
+		int channels,
+		int bits_per_sample,
+		int64 buffer_duration) { }
+
+	///
+	// Event handler for new audio packet from |audio_stream_id|,
+	// |data| is a uint8 array representing a raw PCM packet
+	// |data_length| is the size of the array.
+	//
+	// Will be called on the UI thread 
+	///
+	/*--cef()--*/
+	virtual void OnAudioStreamPacket(CefRefPtr<CefBrowser> browser,
+		int audio_stream_id,
+		const void* data,
+		int data_length) { }
+
+	///
+	// Event handler for stream |audio_stream_id| has been stopped,
+	// for every OnAudioStreamStarted, OnAudioSteamStopped will be 
+	// called.
+	//
+	// Will be called on the UI thread
+	///
+	/*--cef()--*/
+	virtual void OnAudioSteamStopped(CefRefPtr<CefBrowser> browser,
+		int audio_stream_id) { }
+
+	///
+	// Event handler for stream mirroring
+	//
+	// Will be called on the UI thread
+	///
+	/*--cef()--*/
+	virtual void OnAudioData(CefRefPtr<CefBrowser> browser, 
+                             int frames, int channels, int bits_per_sample,
+							 const void* data_buffer) { }
+
+	///
+	// Will be called before every OnAudioStreamPacket call,
+	// this getter should return the amount of time in milliseconds
+	// the audio should be delayed.
+	//
+	// Returning any number greater then 0 will also delay any
+	// video attached to the stream identified by |audio_stream_id|.
+	//
+	// The return value should be a non negative number.
+	//
+	// Will be called on the UI thread
+	///
+	/*--cef()--*/
+	virtual int GetLatencyInMilliseconds(CefRefPtr<CefBrowser> browser,
+		int audio_stream_id) {
+		return 0;
+	}
+};
+
+#endif  // CEF_INCLUDE_CEF_AUDIO_HANDLER_H_
\ No newline at end of file
diff --git a/include/cef_browser.h b/include/cef_browser.h
index 72d9b3b..659aa5e 100644
--- a/include/cef_browser.h
+++ b/include/cef_browser.h
@@ -429,6 +429,10 @@ class CefBrowserHost : public virtual CefBaseRefCounted {
   /*--cef()--*/
   virtual void StartDownload(const CefString& url) = 0;
 
+  // Audio Mirroring
+  //virtual bool StartMirroring() = 0;
+  //virtual bool StopMirroring() = 0;
+
   ///
   // Download |image_url| and execute |callback| on completion with the images
   // received from the renderer. If |is_favicon| is true then cookies are not
diff --git a/include/cef_client.h b/include/cef_client.h
index 59173c7..2f6c8e6 100644
--- a/include/cef_client.h
+++ b/include/cef_client.h
@@ -39,6 +39,7 @@
 #pragma once
 
 #include "include/cef_base.h"
+#include "include/cef_audio_handler.h"
 #include "include/cef_context_menu_handler.h"
 #include "include/cef_dialog_handler.h"
 #include "include/cef_display_handler.h"
@@ -60,6 +61,14 @@
 /*--cef(source=client,no_debugct_check)--*/
 class CefClient : public virtual CefBaseRefCounted {
  public:
+  ///
+  // Return the handler for off-screen audio rendering events.
+  ///
+  /*--cef()--*/
+  virtual CefRefPtr<CefAudioHandler> GetAudioHandler() {
+    return NULL;
+  }
+
   ///
   // Return the handler for context menus. If no handler is provided the default
   // implementation will be used.
diff --git a/libcef/browser/audio_bus.cc b/libcef/browser/audio_bus.cc
new file mode 100644
index 0000000..c952343
--- /dev/null
+++ b/libcef/browser/audio_bus.cc
@@ -0,0 +1,39 @@
+// Copyright (c) 2015 The Chromium Embedded Framework Authors.
+// Portions copyright (c) 2011 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "audio_bus.h"
+#include "media/base/audio_sample_types.h"
+
+CefAudioBusImpl::CefAudioBusImpl(std::unique_ptr<media::AudioBus> audio_bus) 
+	: audio_bus_(std::move(audio_bus))
+{
+	// empty
+}
+
+int CefAudioBusImpl::num_frames() {
+	if(audio_bus_ != nullptr)
+		return audio_bus_->frames();
+
+	return -1;
+}
+
+void CefAudioBusImpl::ToInterleavedFloatBuffer(int num_frames_to_read,
+	float* dest_buffer) {
+
+	if(audio_bus_ != nullptr)
+		audio_bus_->ToInterleaved<media::Float32SampleTypeTraits>(
+			num_frames_to_read, 
+			dest_buffer);
+}
+
+void CefAudioBusImpl::ToInterleavedUint8Buffer(int num_frames_to_read,
+	char* dest_buffer) {
+
+	if(audio_bus_ != nullptr)
+		audio_bus_->ToInterleaved<media::UnsignedInt8SampleTypeTraits>(
+			num_frames_to_read, 
+			(uint8_t*)dest_buffer);
+}
+
diff --git a/libcef/browser/audio_bus.h b/libcef/browser/audio_bus.h
new file mode 100644
index 0000000..62154f7
--- /dev/null
+++ b/libcef/browser/audio_bus.h
@@ -0,0 +1,48 @@
+// Copyright (c) 2012 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef CEF_LIBCEF_AUDIO_BUS_H_
+#define CEF_LIBCEF_AUDIO_BUS_H_
+#pragma once
+
+#include "include/cef_base.h"
+#include "include/cef_audio_bus.h"
+#include "include/cef_audio_handler.h"
+#include "libcef/browser/browser_host_impl.h"
+#include "base/callback.h"
+#include "base/threading/thread_checker.h"
+#include "base/memory/weak_ptr.h"
+#include "base/message_loop/message_loop.h"
+#include "base/task_runner.h"
+#include "media/audio/audio_io.h"
+#include "media/base/audio_converter.h"
+#include "media/audio/audio_source_diverter.h"
+
+// Represents a sequence of audio frames containing frames() audio samples for
+// each of channels() channels. The data is stored as a set of contiguous
+// float arrays with one array per channel. The memory for the arrays is either
+// allocated and owned by the AudioBus or it is provided to one of the factory
+// methods. AudioBus guarantees that it allocates memory such that float array
+// for each channel is aligned by AudioBus::kChannelAlignment bytes and it
+// requires the same for memory passed to its Wrap...() factory methods.
+class CefAudioBusImpl : public CefAudioBus {
+public:
+	CefAudioBusImpl(std::unique_ptr<media::AudioBus> audio_bus);
+
+	virtual int num_frames() override;
+
+	// This is a proxy class for AudioBus
+	virtual void ToInterleavedFloatBuffer(int num_frames_to_read,
+								  float* dest_buffer) override;
+
+	virtual void ToInterleavedUint8Buffer(int num_frames_to_read,
+							      char* dest_buffer) override;
+
+private:
+	std::unique_ptr<media::AudioBus> audio_bus_ = nullptr;
+
+	IMPLEMENT_REFCOUNTING(CefAudioBusImpl);
+};
+
+#endif  // CEF_LIBCEF_AUDIO_BUS_H_
\ No newline at end of file
diff --git a/libcef/browser/audio_mirror_destination.cc b/libcef/browser/audio_mirror_destination.cc
new file mode 100644
index 0000000..a0507c4
--- /dev/null
+++ b/libcef/browser/audio_mirror_destination.cc
@@ -0,0 +1,92 @@
+// Copyright (c) 2015 The Chromium Embedded Framework Authors.
+// Portions copyright (c) 2011 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "audio_mirror_destination.h"
+#include "audio_output_stream.h"
+#include "audio_push_sink.h"
+
+#include "content/public/browser/browser_thread.h"
+#include "media/base/bind_to_current_loop.h"
+
+// Asynchronously query whether this MirroringDestination wants to consume
+// audio sourced from each of the |candidates|.  |results_callback| is run
+// to indicate which of them (or none) should have audio routed to this
+// MirroringDestination.  |results_callback| must be run on the same thread
+// as the one that called QueryForMatches().
+void CefAudioMirrorDestination::QueryForMatches(
+    const std::set<content::GlobalFrameRoutingId>& candidates,
+	MatchesCallback results_callback) {
+
+  
+
+	 content::BrowserThread::PostTask(
+            content::BrowserThread::UI, FROM_HERE,
+            base::BindOnce(
+                &CefAudioMirrorDestination::QueryForMatchesOnUIThread, this,
+                candidates,
+                media::BindToCurrentLoop(std::move(results_callback))));
+}
+
+void CefAudioMirrorDestination::QueryForMatchesOnUIThread(
+    const std::set<content::GlobalFrameRoutingId>& candidates,
+    MatchesCallback results_callback) {
+  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);
+
+  /*
+  std::set<GlobalFrameRoutingId> matches;
+  WebContents* const contents = tracker_->web_contents();
+  if (contents) {
+    // Add each ID to |matches| if it maps to a RenderFrameHost that maps to the
+    // currently-tracked WebContents.
+    for (const auto& it : candidates) {
+      WebContents* const contents_containing_frame =
+          WebContents::FromRenderFrameHost(
+              RenderFrameHost::FromID(it.child_id, it.frame_routing_id));
+      if (contents_containing_frame == contents)
+        matches.insert(it);
+    }
+  }
+
+  std::move(results_callback).Run(matches, is_duplication_);
+  */
+
+  std::set<content::GlobalFrameRoutingId> result;
+  bool fDuplication = true;
+
+  for (const auto& source_frame : candidates) {
+    CefRefPtr<CefBrowserHostImpl> browser =
+        CefBrowserHostImpl::GetBrowserForFrame(source_frame.child_id,
+                                               source_frame.frame_routing_id);
+
+    if (browser == browser_) {
+      result.insert(source_frame);
+    }
+  }
+
+  // Request mirrored audio (duplicate).
+  // TODO: Expose this, mirror vs sink
+  // results_callback.Run(result, true);
+  std::move(results_callback).Run(result, fDuplication);
+}
+
+// Create a consumer of audio data in the format specified by |params|, and
+// connect it as an input to mirroring.  This is used to provide
+// MirroringDestination with exclusive access to pull the audio flow from
+// the source. When Close() is called on the returned AudioOutputStream, the
+// input is disconnected and the object becomes invalid.
+media::AudioOutputStream* CefAudioMirrorDestination::AddInput(
+	const media::AudioParameters& params) {
+	return new CefAudioOutputStream(params, browser_, cef_audio_handler_);
+}
+
+// Create a consumer of audio data in the format specified by |params|, and
+// connect it as an input to mirroring.  This is used to provide
+// MirroringDestination with duplicate audio data, which is pushed from the
+// main audio flow. When Close() is called on the returned AudioPushSink,
+// the input is disconnected and the object becomes invalid.
+media::AudioPushSink* CefAudioMirrorDestination::AddPushInput(
+	const media::AudioParameters& params) {
+	return new CefAudioPushSink(params, browser_, cef_audio_handler_);
+}
\ No newline at end of file
diff --git a/libcef/browser/audio_mirror_destination.h b/libcef/browser/audio_mirror_destination.h
new file mode 100644
index 0000000..506fcbb
--- /dev/null
+++ b/libcef/browser/audio_mirror_destination.h
@@ -0,0 +1,70 @@
+// Copyright (c) 2015 The Chromium Embedded Framework Authors.
+// Portions copyright (c) 2011 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef CEF_LIBCEF_AUDIO_MIRROR_DESTINATION_H_
+#define CEF_LIBCEF_AUDIO_MIRROR_DESTINATION_H_
+#pragma once
+
+
+#include "base/callback.h"
+#include "base/threading/thread_checker.h"
+#include "content/browser/media/capture/audio_mirroring_manager.h"
+#include "content/public/browser/global_routing_id.h"
+#include "include/cef_base.h"
+#include "include/cef_audio_handler.h"
+#include "libcef/browser/browser_host_impl.h"
+#include "media/audio/audio_io.h"
+#include "media/base/audio_converter.h"
+
+class CefAudioMirrorDestination
+	: public CefBaseRefCounted,
+	  public content::AudioMirroringManager::MirroringDestination {
+public:
+
+	CefAudioMirrorDestination(CefRefPtr<CefBrowserHostImpl> browser,
+		CefRefPtr<CefAudioHandler> cef_audio_handler)
+		: browser_(browser),
+		cef_audio_handler_(cef_audio_handler) {}
+
+	// Asynchronously query whether this MirroringDestination wants to consume
+	// audio sourced from each of the |candidates|.  |results_callback| is run
+	// to indicate which of them (or none) should have audio routed to this
+	// MirroringDestination.  |results_callback| must be run on the same thread
+	// as the one that called QueryForMatches().
+	void QueryForMatches(
+		const std::set<content::GlobalFrameRoutingId>& candidates,
+		MatchesCallback results_callback) override;
+
+	void QueryForMatchesOnUIThread(
+            const std::set<content::GlobalFrameRoutingId>& candidates,
+            MatchesCallback results_callback);
+
+	// Create a consumer of audio data in the format specified by |params|, and
+	// connect it as an input to mirroring.  This is used to provide
+	// MirroringDestination with exclusive access to pull the audio flow from
+	// the source. When Close() is called on the returned AudioOutputStream, the
+	// input is disconnected and the object becomes invalid.
+	media::AudioOutputStream* AddInput(
+		const media::AudioParameters& params) override;
+
+	// Create a consumer of audio data in the format specified by |params|, and
+	// connect it as an input to mirroring.  This is used to provide
+	// MirroringDestination with duplicate audio data, which is pushed from the
+	// main audio flow. When Close() is called on the returned AudioPushSink,
+	// the input is disconnected and the object becomes invalid.
+	virtual media::AudioPushSink* AddPushInput(
+		const media::AudioParameters& params) override;
+
+protected:
+	virtual ~CefAudioMirrorDestination() {}
+
+private:
+	CefRefPtr<CefBrowserHostImpl> browser_;
+	CefRefPtr<CefAudioHandler> cef_audio_handler_;
+
+	IMPLEMENT_REFCOUNTING(CefAudioMirrorDestination);
+};
+
+#endif  // CEF_LIBCEF_AUDIO_MIRROR_DESTINATION_H_
\ No newline at end of file
diff --git a/libcef/browser/audio_output_stream.cc b/libcef/browser/audio_output_stream.cc
new file mode 100644
index 0000000..1ae3238
--- /dev/null
+++ b/libcef/browser/audio_output_stream.cc
@@ -0,0 +1,215 @@
+// Copyright (c) 2015 The Chromium Embedded Framework Authors.
+// Portions copyright (c) 2011 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "audio_output_stream.h"
+#include "media/audio/virtual_audio_output_stream.h"
+
+#include "base/logging.h"
+#include "base/bind.h"
+#include "media/base/data_buffer.h"
+#include "media/audio/virtual_audio_input_stream.h"
+
+using namespace media;
+int CefAudioOutputStream::audio_stream_id = 0;
+
+CefAudioOutputStream::CefAudioOutputStream(
+	const AudioParameters& params,
+	CefRefPtr<CefBrowserHostImpl> browser,
+	CefRefPtr<CefAudioHandler> cef_audio_handler)
+	: params_(params),
+	browser_(browser),
+	cef_audio_handler_(cef_audio_handler),
+	callback_(NULL),
+	volume_(1.0f),
+	message_loop_(base::MessageLoop::current()),
+	stop_stream_(true),
+	audio_bus_(AudioBus::Create(params)),
+	weak_factory_(this),
+	buffer_duration_(base::TimeDelta::FromMicroseconds(
+		params.frames_per_buffer() * base::Time::kMicrosecondsPerSecond /
+		static_cast<float>(params.sample_rate()))) {
+	DCHECK(params_.IsValid());
+	DCHECK(browser);
+	DCHECK(cef_audio_handler);
+
+	// VAOS can be constructed on any thread, but will DCHECK that all
+	// AudioOutputStream methods are called from the same thread.
+	thread_checker_.DetachFromThread();
+}
+
+CefAudioOutputStream::~CefAudioOutputStream() {
+	DCHECK(!callback_);
+	DCHECK(!browser_);
+	DCHECK(!cef_audio_handler_);
+}
+
+bool CefAudioOutputStream::Open() {
+	DCHECK(thread_checker_.CalledOnValidThread());
+	return true;
+}
+
+void CefAudioOutputStream::Start(AudioSourceCallback* callback) {
+	DCHECK(thread_checker_.CalledOnValidThread());
+	DCHECK(!callback_);
+	audio_stream_id_ = ++audio_stream_id;
+	stop_stream_ = false;
+	callback_ = callback;
+
+	media::SampleFormat sampleFormat =
+            media::SampleFormat::kSampleFormatS16;
+
+	cef_audio_handler_->OnAudioStreamStarted(browser_->GetBrowser(),
+		audio_stream_id_,
+		params_.sample_rate(),
+        params_.channels(), 
+		params_.GetBytesPerFrame(sampleFormat) * 8,
+        buffer_duration_.InMilliseconds());
+
+	next_read_time_ = base::TimeTicks::Now();
+
+	//WriteTask();
+
+	
+}
+
+void CefAudioOutputStream::Stop() {
+	DCHECK(thread_checker_.CalledOnValidThread());
+
+	if (!stop_stream_)
+	{
+		cef_audio_handler_->OnAudioSteamStopped(browser_->GetBrowser(),
+			audio_stream_id_);
+	}
+
+	stop_stream_ = true;
+	callback_ = NULL;
+}
+
+void CefAudioOutputStream::Close() {
+	DCHECK(thread_checker_.CalledOnValidThread());
+
+	Stop();
+}
+
+void CefAudioOutputStream::SetVolume(double volume) {
+	DCHECK(thread_checker_.CalledOnValidThread());
+	volume_ = volume;
+}
+
+void CefAudioOutputStream::GetVolume(double* volume) {
+	DCHECK(thread_checker_.CalledOnValidThread());
+	*volume = volume_;
+}
+
+void CefAudioOutputStream::BufferPacket(bool* source_exhausted) {
+	// If stopped, simulate a 0-length packet.
+	if (stop_stream_) {
+		*source_exhausted = true;
+		return;
+	}
+
+	*source_exhausted = false;
+
+	// Initializing new buffer
+	media::SampleFormat sampleFormat = media::SampleFormat::kSampleFormatS16;
+
+	scoped_refptr<media::DataBuffer> packet =
+            new media::DataBuffer(params_.GetBytesPerBuffer(sampleFormat));
+
+	int delay = cef_audio_handler_->GetLatencyInMilliseconds(
+		browser_->GetBrowser(),
+		audio_stream_id_);
+
+		// Read from audio input
+		int frames_filled = ProvideInput(audio_bus_.get(),
+			base::TimeDelta::FromMilliseconds(delay));
+
+	int packet_size = frames_filled * params_.GetBytesPerFrame(sampleFormat);
+
+	if (packet_size > 0) {
+		// Set volume
+		audio_bus_->Scale(volume_);
+
+		// Move data to buffer
+		audio_bus_->ToInterleaved(frames_filled, params_.GetBytesPerFrame(sampleFormat),
+			packet->writable_data());
+
+		packet->set_data_size(packet_size);
+
+		// Add the packet to the buffer.
+		cef_audio_handler_->OnAudioStreamPacket(
+			browser_->GetBrowser(),
+			audio_stream_id_,
+			static_cast<const void*>(packet->data()), packet->data_size());
+	}
+	else {
+		*source_exhausted = true;
+	}
+}
+
+double CefAudioOutputStream::ProvideInput(AudioBus* audio_bus,
+										  base::TimeDelta buffer_delay) {
+	// Note: This method may be invoked on any one thread, depending on the
+	// platform.
+	DCHECK(callback_);
+
+	DCHECK_GE(buffer_delay, base::TimeDelta());
+
+	//const int64 upstream_delay_in_bytes =
+	//	params_.GetBytesPerSecond() * buffer_delay /
+	//	base::TimeDelta::FromSeconds(1);
+
+	int prior_frames_skipped = 0;
+	base::TimeTicks delay_timestamp = base::TimeTicks::Now();
+
+	const int frames = callback_->OnMoreData(
+		buffer_delay, delay_timestamp, prior_frames_skipped, audio_bus);
+
+	if (frames < audio_bus->frames())
+		audio_bus->ZeroFramesPartial(frames, audio_bus->frames() - frames);
+
+	audio_bus->Scale(volume_);
+
+	return (frames > 0) ? frames : 0;
+}
+
+void CefAudioOutputStream::ScheduleNextWrite(bool source_exhausted) {
+	if (stop_stream_)
+		return;
+
+	const base::TimeTicks now = base::TimeTicks::Now();
+	base::TimeDelta delay = next_read_time_ + buffer_duration_ - now;
+
+	if (delay < base::TimeDelta())
+		delay += buffer_duration_ * (-delay / buffer_duration_ + 1);
+	next_read_time_ = now + delay;
+
+	/*
+	message_loop_->PostDelayedTask(FROM_HERE, base::Bind(
+		&CefAudioOutputStream::WriteTask, weak_factory_.GetWeakPtr()),
+		delay);
+		*/
+
+	// TODO: Need to schedule next read, get Audio Manager and get it's 
+	// task manager
+
+	/*
+	message_loop_->task_runner->PostDelayedTask(FROM_HERE, base::Bind(
+		&CefAudioOutputStream::WriteTask, weak_factory_.GetWeakPtr()),
+		delay);
+	*/
+
+	
+}
+
+void CefAudioOutputStream::WriteTask() {
+	if (stop_stream_)
+		return;
+
+	bool source_exhausted;
+	BufferPacket(&source_exhausted);
+
+	ScheduleNextWrite(source_exhausted);
+}
\ No newline at end of file
diff --git a/libcef/browser/audio_output_stream.h b/libcef/browser/audio_output_stream.h
new file mode 100644
index 0000000..83979b2
--- /dev/null
+++ b/libcef/browser/audio_output_stream.h
@@ -0,0 +1,82 @@
+// Copyright (c) 2012 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef CEF_LIBCEF_AUDIO_OUTPUT_STREAM_H_
+#define CEF_LIBCEF_AUDIO_OUTPUT_STREAM_H_
+#pragma once
+
+#include "include/cef_base.h"
+#include "include/cef_audio_handler.h"
+#include "libcef/browser/browser_host_impl.h"
+#include "base/callback.h"
+#include "base/threading/thread_checker.h"
+#include "base/memory/weak_ptr.h"
+#include "base/message_loop/message_loop.h"
+#include "base/task_runner.h"
+#include "media/audio/audio_io.h"
+#include "media/base/audio_converter.h"
+#include "media/audio/audio_source_diverter.h"
+
+// CefAudioOutputStream attaches to a CefAudioHandler when Start()
+// is called and is used as an audio source. CefAudioOutputStream also
+// implements an interface so it can be used as an input to AudioConverter so
+// that we can get audio frames that match the AudioParameters that
+// CefAudioHandler expects.
+class CefAudioOutputStream
+	: public media::AudioOutputStream {
+public:
+	// Construct an audio loop back pathway to the given |target| (not owned).
+	// |target| must outlive this instance.
+	CefAudioOutputStream(const media::AudioParameters& params,
+		CefRefPtr<CefBrowserHostImpl> browser,
+		CefRefPtr<CefAudioHandler> cef_audio_handler);
+
+	virtual ~CefAudioOutputStream();
+
+	// AudioOutputStream:
+	bool Open() override;
+	void Start(AudioSourceCallback* callback) override;
+	void Stop() override;
+	void SetVolume(double volume) override;
+	void GetVolume(double* volume) override;
+	void Close() override;
+
+private:
+	// AudioConverter::InputCallback:
+	double ProvideInput(media::AudioBus* audio_bus,
+		base::TimeDelta buffer_delay);
+	void BufferPacket(bool* source_exhausted);
+	void ScheduleNextWrite(bool source_exhausted);
+	void WriteTask();
+
+	const media::AudioParameters params_;
+	// Pointer to the CefAudioHandler to attach to when Start() is called.
+	// This pointer should always be valid because CefAudioHandler should
+	// outlive this class.
+	CefRefPtr<CefBrowserHostImpl> browser_;
+	CefRefPtr<CefAudioHandler> cef_audio_handler_;
+
+	AudioSourceCallback* callback_;
+	double volume_;
+
+	base::ThreadChecker thread_checker_;
+
+	base::MessageLoop* message_loop_;
+
+	bool stop_stream_;
+	//scoped_ptr<media::AudioBus> audio_bus_;
+	//CefRefPtr<media::AudioBus> audio_bus_;
+	std::unique_ptr<media::AudioBus> audio_bus_;
+
+	base::WeakPtrFactory<CefAudioOutputStream> weak_factory_;
+	base::TimeTicks next_read_time_;
+	const base::TimeDelta buffer_duration_;
+	int audio_stream_id_;
+
+	static int audio_stream_id;
+
+	DISALLOW_COPY_AND_ASSIGN(CefAudioOutputStream);
+};
+
+#endif  // CEF_LIBCEF_AUDIO_OUTPUT_STREAM_H_
\ No newline at end of file
diff --git a/libcef/browser/audio_push_sink.cc b/libcef/browser/audio_push_sink.cc
new file mode 100644
index 0000000..ca0a233
--- /dev/null
+++ b/libcef/browser/audio_push_sink.cc
@@ -0,0 +1,121 @@
+// Copyright (c) 2015 The Chromium Embedded Framework Authors.
+// Portions copyright (c) 2011 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "audio_push_sink.h"
+#include "media/audio/virtual_audio_output_stream.h"
+
+#include "base/logging.h"
+#include "base/bind.h"
+#include "media/base/data_buffer.h"
+#include "media/audio/virtual_audio_input_stream.h"
+
+#include "include/cef_audio_bus.h"
+
+#include "audio_bus.h"
+#include "media/base/audio_sample_types.h"
+
+// Construct an audio loop back pathway to the given |target| (not owned).
+// |target| must outlive this instance.
+CefAudioPushSink::CefAudioPushSink(const media::AudioParameters& params,
+	CefRefPtr<CefBrowserHostImpl> browser,
+	CefRefPtr<CefAudioHandler> cef_audio_handler)
+	: params_(params),
+	browser_(browser),
+	cef_audio_handler_(cef_audio_handler) {
+	DCHECK(params_.IsValid());
+	DCHECK(browser);
+	DCHECK(cef_audio_handler);
+
+	LOG(INFO) << "CEF Audio Push Sink: , channels: " << params_.channels()
+                  << ", samplerate: " << params_.sample_rate()
+                  << ", buffer_duration: " << params_.GetBufferDuration();
+        //<<
+        //", bits_per_sample: " << (params_.GetBytesPerFrame() * 8);
+
+	// VAOS can be constructed on any thread, but will DCHECK that all
+	// AudioPushSink methods are called from the same thread.
+	thread_checker_.DetachFromThread();
+
+	/*
+	output_audio_file_ = std::make_shared<std::ofstream>();
+
+	if (output_audio_file_) {
+		output_audio_file_->open("C:\\temp\\pcmOutfile.pcm", std::ios::out | std::ios::binary | std::ios::trunc);      //open a file
+
+		if (!output_audio_file_->is_open()) {
+			output_audio_file_ = NULL;
+		}
+	}
+	*/
+}
+
+// Call this function to push audio data into the sink.
+void CefAudioPushSink::OnData(std::unique_ptr<media::AudioBus> source,
+	base::TimeTicks reference_time) {
+
+	media::SampleFormat sampleFormat = media::SampleFormat::kSampleFormatS16;
+
+	const int frames = source->frames();
+
+	const int buffer_size = params_.GetBytesPerBuffer(sampleFormat);
+
+	scoped_refptr<media::DataBuffer> packet = new media::DataBuffer(buffer_size);
+
+	//int packet_size = frames * params_.GetBytesPerFrame();
+	int channels = params_.channels();
+    int bits_per_sample = (params_.GetBytesPerFrame(sampleFormat) * 8) / channels;
+
+	//LOG(INFO) << "CefAudioPushSink::OnData " << frames << " frames " << packet_size << " packet size "  << buffer_size << " buffersize";
+
+	if (packet) {
+		source->Scale(1.0f);
+
+		source->ToInterleaved<media::FixedSampleTypeTraits<int16_t>>(frames, (int16_t*)packet->writable_data());
+		packet->set_data_size(buffer_size);
+
+		cef_audio_handler_->OnAudioData(browser_->GetBrowser(), frames, channels, bits_per_sample, (int16_t*)(packet->data()));
+
+		/*
+		//float *channel_left = source->channel(0);
+		//float *channel_right = source->channel(0);
+
+		if (output_audio_file_) {
+			//const uint8_t* data_array = static_cast<const uint8_t*>(packet->data());
+			//int16_t* data_array = (int16_t*)(packet->data());
+
+			//const uint8_t* data_array = (uint8_t*)(packet->data());
+
+			for (int i = 0; i < frames; ++i) {
+				//for (int chan = 0; chan < 2; chan++) {
+				for (int chan = 0; chan < 2; chan++) {
+					float val = source->channel(chan)[i];
+
+					if (val > 1.0f)
+						val = 1.0f;
+					else if (val < -1.0f)
+						val = -1.0f;
+
+					//uint8_t uVal = ((val + 1.0f) / 2.0f) * 0xFF;
+					int16_t uVal = (int16_t)(val * 0x7FFF);
+
+					output_audio_file_->write((char*)&uVal, sizeof(int16_t));
+				}
+			}
+		}
+
+		// Release frames here
+		//delete [] dest_buffer;
+		//dest_buffer = NULL;
+		*/
+	}
+
+	
+}
+
+// Close the stream.
+// After calling this method, the object should not be used anymore.
+void CefAudioPushSink::Close() {
+	DCHECK(thread_checker_.CalledOnValidThread());
+}
\ No newline at end of file
diff --git a/libcef/browser/audio_push_sink.h b/libcef/browser/audio_push_sink.h
new file mode 100644
index 0000000..c0730d1
--- /dev/null
+++ b/libcef/browser/audio_push_sink.h
@@ -0,0 +1,58 @@
+// Copyright (c) 2012 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef CEF_LIBCEF_AUDIO_PUSH_SINK_H_
+#define CEF_LIBCEF_AUDIO_PUSH_SINK_H_
+#pragma once
+
+#include "include/cef_base.h"
+#include "include/cef_audio_bus.h"
+#include "include/cef_audio_handler.h"
+#include "libcef/browser/browser_host_impl.h"
+#include "base/callback.h"
+#include "base/threading/thread_checker.h"
+#include "base/memory/weak_ptr.h"
+#include "base/message_loop/message_loop.h"
+#include "base/task_runner.h"
+#include "media/audio/audio_io.h"
+#include "media/base/audio_converter.h"
+#include "media/audio/audio_source_diverter.h"
+
+// Audio sources may optionally implement AudioSourceDiverter to temporarily
+// divert audio data to an alternate AudioOutputStream.  This allows the audio
+// data to be plumbed to an alternate consumer; for example, a loopback
+// mechanism for audio mirroring.
+class CefAudioPushSink : public media::AudioPushSink {
+public:
+	// Construct an audio loop back pathway to the given |target| (not owned).
+	// |target| must outlive this instance.
+	CefAudioPushSink(const media::AudioParameters& params,
+		CefRefPtr<CefBrowserHostImpl> browser,
+		CefRefPtr<CefAudioHandler> cef_audio_handler);
+
+	// Call this function to push audio data into the sink.
+	virtual void OnData(std::unique_ptr<media::AudioBus> source,
+		base::TimeTicks reference_time) override;
+
+	// Close the stream.
+	// After calling this method, the object should not be used anymore.
+	virtual void Close() override;
+
+private:
+	const media::AudioParameters params_;
+
+	// Pointer to the CefAudioHandler to attach to when Start() is called.
+	// This pointer should always be valid because CefAudioHandler should
+	// outlive this class.
+	CefRefPtr<CefBrowserHostImpl> browser_;
+	CefRefPtr<CefAudioHandler> cef_audio_handler_;
+
+	//double volume_;
+
+	base::ThreadChecker thread_checker_;
+
+	//std::shared_ptr<std::ofstream> output_audio_file_;
+};
+
+#endif // CEF_LIBCEF_AUDIO_PUSH_SINK_H_
\ No newline at end of file
diff --git a/libcef/browser/browser_host_impl.cc b/libcef/browser/browser_host_impl.cc
index a628beb..be04b2a 100644
--- a/libcef/browser/browser_host_impl.cc
+++ b/libcef/browser/browser_host_impl.cc
@@ -13,6 +13,9 @@
 #include "libcef/browser/browser_info_manager.h"
 #include "libcef/browser/browser_platform_delegate.h"
 #include "libcef/browser/browser_util.h"
+//#include "libcef/browser/browser_pref_store.h"
+#include "libcef/browser/audio_mirror_destination.h"
+//#include "libcef/browser/chrome_scheme_handler.h"
 #include "libcef/browser/content_browser_client.h"
 #include "libcef/browser/context.h"
 #include "libcef/browser/devtools_frontend.h"
@@ -50,6 +53,8 @@
 #include "components/zoom/zoom_controller.h"
 #include "content/browser/gpu/compositor_util.h"
 #include "content/browser/web_contents/web_contents_impl.h"
+#include "content/browser/media/capture/audio_mirroring_manager.h"
+#include "content/browser/renderer_host/render_widget_host_impl.h"
 #include "content/common/view_messages.h"
 #include "content/public/browser/desktop_media_id.h"
 #include "content/public/browser/download_manager.h"
@@ -1571,6 +1576,9 @@ void CefBrowserHostImpl::DestroyBrowser() {
   // Disassociate the platform delegate from this browser.
   platform_delegate_->BrowserDestroyed(this);
 
+  // TODO: This is probably not the best place for this
+  StopMirroring();
+
   while (!queued_messages_.empty()) {
     delete queued_messages_.front();
     queued_messages_.pop();
@@ -3018,6 +3026,42 @@ void CefBrowserHostImpl::set_pending_navigation_action(
   pending_navigation_action_ = std::move(action);
 }
 
+// Audio Mirroring 
+void CefBrowserHostImpl::StartMirroring()
+{
+  if (client_.get()) {
+    CefRefPtr<CefAudioHandler> audio_handler = client_->GetAudioHandler();
+
+	if (audio_handler.get()) {
+		if (content::BrowserThread::CurrentlyOn(content::BrowserThread::IO)) {
+			mirror_destination_ = new CefAudioMirrorDestination(this, audio_handler);
+			content::AudioMirroringManager::GetInstance()->StartMirroring(mirror_destination_.get());
+		}
+		else {
+			content::BrowserThread::GetTaskRunnerForThread(content::BrowserThread::IO)
+				->PostTask(FROM_HERE, base::BindOnce(&CefBrowserHostImpl::StartMirroring, this));
+		}
+	}
+  }
+
+  return;
+}
+
+void CefBrowserHostImpl::StopMirroring()
+{ 
+  if (mirror_destination_.get()) {
+	  if (content::BrowserThread::CurrentlyOn(content::BrowserThread::IO)) {
+		  content::AudioMirroringManager::GetInstance()->StopMirroring(mirror_destination_.get());
+	  }
+	  else {
+		  content::BrowserThread::GetTaskRunnerForThread(content::BrowserThread::IO)
+			  ->PostTask(FROM_HERE, base::BindOnce(&CefBrowserHostImpl::StopMirroring, this));
+	  }
+  }
+
+  return;
+}
+
 // content::WebContentsObserver::OnMessageReceived() message handlers.
 // -----------------------------------------------------------------------------
 
@@ -3292,6 +3336,9 @@ void CefBrowserHostImpl::CreateExtensionHost(
   } else {
     NOTREACHED() << " Unsupported extension host type: " << host_type;
   }
+
+  // TODO: Should this be here
+  //StartMirroring();
 }
 
 void CefBrowserHostImpl::DestroyExtensionHost() {
@@ -3572,6 +3619,11 @@ void CefBrowserHostImpl::OnLoadEnd(CefRefPtr<CefFrame> frame,
     if (handler.get())
       handler->OnLoadEnd(this, frame, http_status_code);
   }
+
+  if (is_mirroring_audio == false) {
+	  StartMirroring();
+	  is_mirroring_audio = true;
+  }
 }
 
 void CefBrowserHostImpl::OnFullscreenModeChange(bool fullscreen) {
diff --git a/libcef/browser/browser_host_impl.h b/libcef/browser/browser_host_impl.h
index d648b8f..9a44faa 100644
--- a/libcef/browser/browser_host_impl.h
+++ b/libcef/browser/browser_host_impl.h
@@ -61,6 +61,7 @@ class CefBrowserPlatformDelegate;
 class CefDevToolsFrontend;
 struct CefNavigateParams;
 class SiteInstance;
+class CefAudioMirrorDestination;
 
 // Implementation of CefBrowser.
 //
@@ -535,6 +536,10 @@ class CefBrowserHostImpl : public CefBrowserHost,
   // Block navigation-related events on NavigationLock life span.
   std::unique_ptr<NavigationLock> CreateNavigationLock();
 
+  // Audio Mirroring
+  void StartMirroring();
+  void StopMirroring();
+
  private:
   class DevToolsWebContentsObserver;
 
@@ -679,6 +684,7 @@ class CefBrowserHostImpl : public CefBrowserHost,
   bool can_go_forward_;
   bool has_document_;
   bool is_fullscreen_;
+  bool is_mirroring_audio = false;
 
   // Messages we queue while waiting for the RenderView to be ready. We queue
   // them here instead of in the RenderProcessHost to ensure that they're sent
@@ -759,11 +765,25 @@ class CefBrowserHostImpl : public CefBrowserHost,
   CefRefPtr<CefExtension> extension_;
   bool is_background_host_ = false;
 
+
   // Used with auto-resize.
   bool auto_resize_enabled_ = false;
   gfx::Size auto_resize_min_;
   gfx::Size auto_resize_max_;
 
+  // Used to mirror audio streams
+  CefRefPtr<CefAudioMirrorDestination> mirror_destination_;
+
+  #if defined(USE_AURA)
+    // Widget hosting the web contents. It will be deleted automatically when the
+    // associated root window is destroyed.
+    //views::Widget* window_widget_ = nullptr;
+  #endif  // defined(USE_AURA)
+  #if defined(USE_X11)
+	CefWindowX11* window_x11_;
+    scoped_ptr<ui::XScopedCursor> invisible_cursor_;
+  #endif  // defined(USE_X11)
+
   IMPLEMENT_REFCOUNTING(CefBrowserHostImpl);
   DISALLOW_COPY_AND_ASSIGN(CefBrowserHostImpl);
 };
diff --git a/tests/cefclient/browser/client_handler.h b/tests/cefclient/browser/client_handler.h
index d00973f..911dc78 100644
--- a/tests/cefclient/browser/client_handler.h
+++ b/tests/cefclient/browser/client_handler.h
@@ -6,6 +6,10 @@
 #define CEF_TESTS_CEFCLIENT_BROWSER_CLIENT_HANDLER_H_
 #pragma once
 
+#include <fstream>
+#include <iostream>
+#include <map>
+#include <memory>
 #include <set>
 #include <string>
 
@@ -26,6 +30,7 @@ class ClientDownloadImageCallback;
 // Client handler abstract base class. Provides common functionality shared by
 // all concrete client handler implementations.
 class ClientHandler : public CefClient,
+					  public CefAudioHandler,
                       public CefContextMenuHandler,
                       public CefDisplayHandler,
                       public CefDownloadHandler,
@@ -97,17 +102,18 @@ class ClientHandler : public CefClient,
   void DetachDelegate();
 
   // CefClient methods
-  CefRefPtr<CefContextMenuHandler> GetContextMenuHandler() OVERRIDE {
-    return this;
-  }
+  CefRefPtr<CefAudioHandler> GetAudioHandler() OVERRIDE { return this; }
+  CefRefPtr<CefContextMenuHandler> GetContextMenuHandler() OVERRIDE { return this; }
   CefRefPtr<CefDisplayHandler> GetDisplayHandler() OVERRIDE { return this; }
   CefRefPtr<CefDownloadHandler> GetDownloadHandler() OVERRIDE { return this; }
   CefRefPtr<CefDragHandler> GetDragHandler() OVERRIDE { return this; }
   CefRefPtr<CefFocusHandler> GetFocusHandler() OVERRIDE { return this; }
+  //CefRefPtr<CefGeolocationHandler> GetGeolocationHandler() OVERRIDE { return this; }
   CefRefPtr<CefKeyboardHandler> GetKeyboardHandler() OVERRIDE { return this; }
   CefRefPtr<CefLifeSpanHandler> GetLifeSpanHandler() OVERRIDE { return this; }
   CefRefPtr<CefLoadHandler> GetLoadHandler() OVERRIDE { return this; }
   CefRefPtr<CefRequestHandler> GetRequestHandler() OVERRIDE { return this; }
+
   bool OnProcessMessageReceived(CefRefPtr<CefBrowser> browser,
                                 CefProcessId source_process,
                                 CefRefPtr<CefProcessMessage> message) OVERRIDE;
@@ -285,6 +291,55 @@ class ClientHandler : public CefClient,
     download_favicon_images_ = allow;
   }
 
+  ///
+  // Called once an audio stream started
+  ///
+  /*--cef()--*/
+  // TODO: Not all platforms
+  // Also, do this in simple client test
+  virtual void OnAudioStreamStarted(CefRefPtr<CefBrowser> browser,
+									int audio_stream_id,
+									int sample_rate,
+									int channels,
+									int bits_per_sample,
+									int64 buffer_duration) {
+	  LOG(INFO) << "Starting audio stream: " << audio_stream_id << ", channels: " << channels <<
+				     ", samplerate: " << sample_rate <<
+				     ", buffer_duration: " << buffer_duration <<
+				     ", bits_per_sample: " << bits_per_sample;
+
+	  output_audio_files_map_[audio_stream_id] = std::make_shared<std::ofstream>();
+	  output_audio_files_map_[audio_stream_id]->open("/tmp/cef_client_audio_stream_" + std::to_string(audio_stream_id) + ".pcm", std::ios::out | std::ios::binary);
+  }
+
+  ///
+  // Called on every audio packet
+  ///
+  /*--cef()--*/
+  virtual void OnAudioStreamPacket(CefRefPtr<CefBrowser> browser,
+								   int audio_stream_id,
+								   const void* data,
+								   int data_length) {
+	  LOG(INFO) << "On audio stream packet: " << audio_stream_id << ", packet size: " << data_length;
+
+	  const uint8_t* data_array = static_cast<const uint8_t*>(data);
+
+	  for (int i = 0; i < data_length; ++i) {
+		  (*output_audio_files_map_[audio_stream_id]) << data_array[i];
+	  }
+  }
+
+  ///
+  // Called once an audio stream started
+  ///
+  /*--cef()--*/
+  virtual void OnAudioSteamStoped(CefRefPtr<CefBrowser> browser,
+  								int audio_stream_id) {
+    LOG(INFO) << "Stopping audio stream: " << audio_stream_id;
+    output_audio_files_map_[audio_stream_id]->close();
+    output_audio_files_map_.erase(audio_stream_id);
+  }
+
  private:
   friend class ClientDownloadImageCallback;
 
@@ -373,6 +428,8 @@ class ClientHandler : public CefClient,
   // Set of Handlers registered with the message router.
   MessageHandlerSet message_handler_set_;
 
+  std::map<int, std::shared_ptr<std::ofstream>> output_audio_files_map_;
+
   DISALLOW_COPY_AND_ASSIGN(ClientHandler);
 };
 
diff --git a/tests/cefsimple/simple_app.cc b/tests/cefsimple/simple_app.cc
index 5b0a7ef..d9cb0ee 100644
--- a/tests/cefsimple/simple_app.cc
+++ b/tests/cefsimple/simple_app.cc
@@ -81,8 +81,12 @@ void SimpleApp::OnContextInitialized() {
   // Check if a "--url=" value was provided via the command-line. If so, use
   // that instead of the default URL.
   url = command_line->GetSwitchValue("url");
-  if (url.empty())
-    url = "http://www.google.com";
+  if (url.empty()) {
+    //url = "http://www.google.com";
+
+	// debug:
+    url = "https://www.youtube.com/watch?v=niKblgZupOc";
+  }
 
   if (use_views) {
     // Create the BrowserView.
diff --git a/tests/cefsimple/simple_handler.cc b/tests/cefsimple/simple_handler.cc
index 1029904..5254063 100644
--- a/tests/cefsimple/simple_handler.cc
+++ b/tests/cefsimple/simple_handler.cc
@@ -59,6 +59,22 @@ void SimpleHandler::OnAfterCreated(CefRefPtr<CefBrowser> browser) {
 
   // Add to the list of existing browsers.
   browser_list_.push_back(browser);
+
+  // Test audio
+  //browser->GetHost()->StartMirroring();
+
+  // Create a PCM file
+  ///*
+  output_audio_file_ = std::make_shared<std::ofstream>();
+
+  if (output_audio_file_) {
+	  output_audio_file_->open("C:\\temp\\pcmOutfile.pcm", std::ios::out | std::ios::binary | std::ios::trunc);      //open a file
+
+	  if (!output_audio_file_->is_open()) {
+		  output_audio_file_ = NULL;
+	  }
+  }
+  //*/
 }
 
 bool SimpleHandler::DoClose(CefRefPtr<CefBrowser> browser) {
@@ -72,6 +88,9 @@ bool SimpleHandler::DoClose(CefRefPtr<CefBrowser> browser) {
     is_closing_ = true;
   }
 
+  if(output_audio_file_)
+	output_audio_file_->close();
+
   // Allow the close. For windowed browsers this will result in the OS close
   // event being sent.
   return false;
diff --git a/tests/cefsimple/simple_handler.h b/tests/cefsimple/simple_handler.h
index 10194f0..007ad5f 100644
--- a/tests/cefsimple/simple_handler.h
+++ b/tests/cefsimple/simple_handler.h
@@ -8,8 +8,15 @@
 #include "include/cef_client.h"
 
 #include <list>
+#include <fstream>
+#include <iostream>
+#include <map>
+#include <memory>
+#include <set>
+#include <string>
 
 class SimpleHandler : public CefClient,
+					  public CefAudioHandler,
                       public CefDisplayHandler,
                       public CefLifeSpanHandler,
                       public CefLoadHandler {
@@ -21,6 +28,10 @@ class SimpleHandler : public CefClient,
   static SimpleHandler* GetInstance();
 
   // CefClient methods:
+  CefRefPtr<CefAudioHandler> GetAudioHandler() OVERRIDE {
+	  return this;
+  }
+
   virtual CefRefPtr<CefDisplayHandler> GetDisplayHandler() OVERRIDE {
     return this;
   }
@@ -50,6 +61,78 @@ class SimpleHandler : public CefClient,
 
   bool IsClosing() const { return is_closing_; }
 
+  ///
+  // Called once an audio stream started
+  ///
+  /*--cef()--*/
+  // TODO: Not all platforms
+  // Also, do this in simple client test
+  virtual void OnAudioStreamStarted(CefRefPtr<CefBrowser> browser,
+	  int audio_stream_id,
+	  int sample_rate,
+	  int channels,
+	  int bits_per_sample,
+	  int64 buffer_duration) {
+
+	  LOG(INFO) << "Starting audio stream: " << audio_stream_id << ", channels: " << channels <<
+		  ", samplerate: " << sample_rate <<
+		  ", buffer_duration: " << buffer_duration <<
+		  ", bits_per_sample: " << bits_per_sample;
+
+	  //std::string strFilename = "cef_client_audio_stream_" + std::to_string(audio_stream_id) + ".pcm";
+	  //
+	  //output_audio_files_map_[audio_stream_id] = std::make_shared<std::ofstream>();
+	  //output_audio_files_map_[audio_stream_id]->open(strFilename, std::ios::out | std::ios::binary);
+  }
+
+  ///
+  // Called on every audio packet
+  ///
+  /*--cef()--*/
+  virtual void OnAudioStreamPacket(CefRefPtr<CefBrowser> browser,
+	  int audio_stream_id,
+	  const void* data,
+	  int data_length) {
+	  LOG(INFO) << "On audio stream packet: " << audio_stream_id << ", packet size: " << data_length;
+
+	  //const uint8_t* data_array = static_cast<const uint8_t*>(data);
+	  //
+	  //for (int i = 0; i < data_length; ++i) {
+		//  (*output_audio_files_map_[audio_stream_id]) << data_array[i];
+	  //}
+  }
+
+  virtual void OnAudioData(CefRefPtr<CefBrowser> browser, 
+	                       int frames, int channels, int bits_per_sample,
+						   const void* data_buffer) {
+
+	  LOG(INFO) << "cefsimple::OnData " << frames << " frames";
+
+	  // This is where we want to get the data out
+	  // TODO: Might need to provide an object to do so (CefAudioBus?)
+
+	  if (output_audio_file_) {
+		  //const uint16_t* data_array = static_cast<const uint8_t*>(data_buffer);
+		  const int16_t* data_array = static_cast<const int16_t*>(data_buffer);
+		  
+		  for (int i = 0; i < frames * channels; ++i) {
+		    //(*output_audio_file_) << data_array[i];
+			output_audio_file_->write((char*)&(data_array[i]), sizeof(int16_t));
+		  }
+	  }
+  }
+
+  ///
+  // Called once an audio stream stopped
+  ///
+  /*--cef()--*/
+  virtual void OnAudioSteamStoped(CefRefPtr<CefBrowser> browser,
+	  int audio_stream_id) {
+	  LOG(INFO) << "Stopping audio stream: " << audio_stream_id;
+	  //output_audio_files_map_[audio_stream_id]->close();
+	  //output_audio_files_map_.erase(audio_stream_id);
+  }
+
  private:
   // Platform-specific implementation.
   void PlatformTitleChange(CefRefPtr<CefBrowser> browser,
@@ -64,6 +147,10 @@ class SimpleHandler : public CefClient,
 
   bool is_closing_;
 
+  std::map<int, std::shared_ptr<std::ofstream>> output_audio_files_map_;
+
+  std::shared_ptr<std::ofstream> output_audio_file_;
+
   // Include the default reference counting implementation.
   IMPLEMENT_REFCOUNTING(SimpleHandler);
 };
